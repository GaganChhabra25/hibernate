http://www.dineshonjava.com/p/proxy-objects-and-eager-and-lazy-fetch.html#.WLcPdFZ97CI

========================
HIBERNATE PROPERTIES:
========================

Configuration ----> SessionFactory ------>Session ---------> Transaction ---------> Database


hbm2ddl.auto-->create -Always create new schema
hbm2ddl.auto-->update -Update existing schema

1. <property name="hbm2ddl.auto">create</property>

        hbm2ddl  --->  means hibernate mapping to create schema DDL (Data Definition Language).

       When the SessionFactory is created, automatically validates or exports schema DDL to the database .
       With create-drop, the database schema will be dropped when the SessionFactory is closed explicitly.
       This means, everytime the previous data will be  destroyed

2.  <property name="hbm2ddl.auto">update</property>



========================
3. ANNOTATIONS :
========================

1. @Entity  : means it telling hibernate this class treat as entity and need to save it the database.

2. @ID      : means it telling hibernate this property treat as primary key of the table.
            : @Id- Specifies the primary key of an entity. Example-

                  @Id
                  private long userId;

3. @GeneratedValue Provides for the specification of generation strategies for the values of primary keys.

    <generator> element:

   Used to create primary key for new record, there are some commonly used generators type given below...
   Increment- used to generate primary keys of type long, short or int that are unique only.
   Sequence  - used to generate primary keys for DB2, Oracle, SAP Database.
   Assigned  - is used when application code generates the primary key.
   Native       - selects identity, sequence or hilo depending upon the capabilities of the underlying db.
   Identity     - supports identity columns in DB2, MySQL, MS SQL Server, Sybase and HypersonicSQL. The returned identifier is of type long, short or int.
   Uuid  - Unique use ID of 128 bits generated from using algorithm and return type is String
   hilo  - generated by the hi/lo Algorithm
   seqhilo - generated by the hi/lo Algorithm according to sequence of database
   select - select from database triggered value
   foreign - associated with the other model objects

4. @Transient - Used if we  want to skip any field of entity class to save in the database. Example-

           @Transient
           private String middleName;

5. @Temporal- This annotation must be specified for persistent fields or properties of type
              java.util.Date and java.util.Calendar. Example-

                   @Column(name="JOIN_DATE")
                   @Temporal(TemporalType.DATE)
                       private Date joinDate;

6. @Embeddable:

        Target  -> Classes
        Defines a class whose instances are stored as an intrinsic part of an owning entity and share the identity of the
        entity. Each of the persistent properties or fields of the embedded object is mapped to the database table for the
        entity.

        Does not have real meaning for self individually.In database no separate table will be created for embeddable class.

        Example :
        ---------

        @Embeddable                             Class User {
         public class Address                       @Embedded
         { }                                        Address address;
                                                }

         One class can embedd multiple embeddable classes. i.e Embeddabele class can have List<Embeddable_Class> embeddableClasses;

7. @ElementCollection:

        Target --->  Fields (including property get methods)
        Defines a collection of instances of a basic type or embeddable class

        @ElementCollection // Defines List of embeddable classes
        List<Embeddable_Class> embeddableClasses;\


8. @JoinTable:
         Target:  Fields (including property get methods)

          Used in the mapping of associations. It is specified on the owning side of an association.
         A join table is typically used in the mapping of many-to-many and unidirectional one-to-many associations.
         It may also be used to map bidirectional many-to-one/one-to-many associations, unidirectional many-to-one
         relationships, and one-to-one associations (both bidirectional and unidirectional).

         EXAMPLE :
         -----------

             @ElementCollection
             @JoinTable(name="USER_ADDRESS")//name of the table is changed to USER_ADDRESS
             private Collection<Address> lisOfAddresses = new ArrayList<Address>();


9. @JoinColumn:
   Target:   Fields (including property get methods)

   Specifies a column for joining an entity association or element collection. If the JoinColumn annotation itself is defaulted,
   a single join column is assumed and the default values apply.

    EXAMPLE:
    ---------
              @ElementCollection
                @JoinTable(name="USER_ADDRESS", joinColumns=@JoinColumn(name="USER_ID"))
                private Collection<Address> lisOfAddresses = new ArrayList<Address>();

=======================================================
Retrieving Objects in Hibernate using session.get :
========================================================

      user = (UserDetails) session.get(UserDetails.class, 1);

      we get user object from session object using method session.get(Class arg1, Serializable arg2)

       --> arg1 is the what the model object we want to retrieve from database.
       --> arg2 is primary key or id of the fetching object

=====================================================
Value Types and Embedding Objects in Hibernate:
=====================================================

There are two type of objects :
    1. Entity type objects
    2. Value type objects OR Embeddabel objects

Object of Entity Type : has its own database identity
Object of Value Type : belongs to an entity, and its persistent state is embedded in the table row of the owning entity.
                       Value types don't have identifiers or identifier properties.

     EXAMPLE of Entity Type Objects
     ------------------------------                 USER TABLE
                                                    -----------------------------------
     Class User {                                  | ID | NAME | ADDRESS | PHONE | DATE |
        userId;                                     -----------------------------------
        userName;       ----------------->
        address;
        phone;
        Date;
     }

     In Above table we saw that type of the all fields of the class USER CLASS have database entity type object.
                   ID            is INTEGER type
                   Name          is VARCHAR type
                   ADDRESS       is VARCHAR type
                   Phone         is BIG INTEGER type
                   DOB           is TIMESTAMP type
     All are the Entity Type Objects.

======================
1. Proxy Objects:
=====================


Hibernate Proxy Object:  An object proxy is just a way to avoid retrieving an object until you need it.

Suppose user class has the three field values-
1. User Id
2. User Name
3. List of the Addresses

If you want retrieve user object from the database, so what field value are retrieved from the database and which field
are initialized. Suppose one user XYZ has the 100 addresses in the database and we want to retrieved the name of this
user from database. For that we retrieve the user object, now question is this what about the field listOfAddress field,
Is it also have the value? if you say yes so what about cost of memory ? if you say no so how to retrieve the value
associated with that field the address table in the database on demand.

when we fetching the user object from the database actually its retrieved the proxy object of the user class means only
first level of the fields are initializing with the associated values from the database. Field listOfAddresses does not
have the value. If you want the list address you should call the following method you will get the listOfAddresses.

     user.getListOfAddress(); --->> this return the list of the address associated with that particular user which name is
                                    XYZ this is the default behavior of the Hibernate 3.

==========================
2. Fetching Strategies:
==========================

Fetching Strategies:  there are two types of the fetching strategies in the hibernate.
1. Lazy Fetch type
2. Eager Fetch type
                  LAZY = fetch when needed
                  EAGER = fetch immediately

1. Lazy Fetch Type: This the default fetch type of the hibernate 3.

        Now when you load a User from the database, JPA loads its id, name, and address fields for you. But you have two options for
        users: to load it together with the rest of the fields (i.e. eagerly) or to load it on-demand (i.e. lazily) when you call
        the user's getListOfAddresses() method.

        Lazy/Select Fetch strategy:- Select Fetch strategy is the lazy fetching of associations. The purpose of Lazy strategy is
        memory optimization . When I say memory optimization it means it means it saves us from heap error. This is what I think.
        So we can say yes if we are loading too objects in aseesion we should go for Lazy Fetch strategy but in terms of time
        performance it does not provide any Benefit. Agreed?

        When a user has many addresses it is not efficient to load all of its addresses with it when they are not needed. So in s
        uchlike cases, you can declare that you want addresses to be loaded when they are actually needed. This is called lazy loading.


2. Eager Fetch Strategy: In hibernate 2 this is default behavior of the to retrieving an object from the database.

        Eager/Join Fetch strategy:- Join Fetch strategy the eager fetching of associations.The purpose of Join Fetch strategy is
        optimization in terms of time.I mean even associations are fetched right at the time of fetching parent object. So in this
        case we don’t make database call again and again . So this will be much faster.Agreed that this will bad if we are fetching
        too many objects in a session because we can get java heap error.

